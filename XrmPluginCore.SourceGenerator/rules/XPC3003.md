# XPC3003: Image registration without method reference

## Severity

Warning

## Description

This rule reports when `WithPreImage()` or `WithPostImage()` is used with a lambda invocation expression (e.g., `s => s.HandleUpdate()`) instead of a method reference expression (e.g., `nameof(IService.HandleUpdate)`). When images are registered with the modern API, the source generator needs to know the method name to generate type-safe wrapper classes and validate the handler signature. Method invocation syntax prevents the generator from extracting this information.

**Note:** This rule only applies to the modern `WithPreImage()`/`WithPostImage()` API. For the legacy `AddImage()` API, see [XPC3002](XPC3002.md).

## ❌ Example of violation

```csharp
public class AccountPlugin : Plugin
{
    public AccountPlugin()
    {
        // XPC3003: WithPreImage/WithPostImage requires method reference syntax
        RegisterStep<Account, IAccountService>(
            EventOperation.Update,
            ExecutionStage.PostOperation,
            s => s.HandleUpdate())  // Method invocation with parentheses - BAD
            .WithPreImage(x => x.Name);
    }
}

public interface IAccountService
{
    void HandleUpdate(PreImage preImage);
}
```

## ✅ How to fix

Use `nameof()` to reference the handler method when registering images:

```csharp
public class AccountPlugin : Plugin
{
    public AccountPlugin()
    {
        // Correct: Use nameof() for method reference when images are registered
        RegisterStep<Account, IAccountService>(
            EventOperation.Update,
            ExecutionStage.PostOperation,
            nameof(IAccountService.HandleUpdate))  // nameof() for compile-time safety
            .WithPreImage(x => x.Name);
    }
}

public interface IAccountService
{
    void HandleUpdate(PreImage preImage);
}
```

### When to use each syntax

| Registration Type | Recommended Syntax | Example |
|-------------------|-------------------|---------|
| With images | `nameof()` | `nameof(IService.Method)` |
| Without images | Lambda invocation | `s => s.Method()` |

## Why this matters

1. **Type-safe wrapper generation**: The source generator creates strongly-typed `PreImage` and `PostImage` wrapper classes based on the registered attributes. It needs to know the handler method name to generate and inject these wrappers correctly.

2. **Signature validation**: When using `nameof()`, the source generator can validate that the handler method's signature matches the registered images (XPC4002). With lambda invocation syntax, this validation cannot be performed.

3. **Runtime behavior**: Without the method reference, the source generator cannot generate the wrapper classes. This means your handler method will not receive the type-safe image wrappers, and you'll need to manually extract images from the execution context.

4. **Consistency**: Using `nameof()` when images are registered and lambda invocation when no images are needed creates a clear pattern that indicates what each registration expects.

## See also

- [XPC3001: Prefer nameof over string literal](XPC3001.md)
- [XPC4002: Handler signature does not match registered images](XPC4002.md)
- [XPC3002: Consider using modern image registration API](XPC3002.md)
