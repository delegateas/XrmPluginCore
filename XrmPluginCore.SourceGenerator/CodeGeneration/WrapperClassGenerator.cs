using System.Collections.Generic;
using System.Linq;
using System.Text;
using XrmPluginCore.SourceGenerator.Models;

namespace XrmPluginCore.SourceGenerator.CodeGeneration;

/// <summary>
/// Generates wrapper class source code for plugin step registrations
/// </summary>
internal static class WrapperClassGenerator
{
	/// <summary>
	/// Generates a complete source file containing wrapper classes for a plugin step registration.
	/// Generates PreImage and PostImage wrappers, and ActionWrapper for the new method reference API.
	/// </summary>
	public static string GenerateWrapperClasses(PluginStepMetadata metadata)
	{
		var imagesWithAttributes = metadata.Images.Where(i => i.Attributes.Any()).ToList();

		// Estimate capacity: ~500 chars per image wrapper class + ~300 for ActionWrapper
		var estimatedCapacity = (imagesWithAttributes.Count * 500) + 500;
		var sb = new StringBuilder(estimatedCapacity);

		// File header
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine();

		// Using directives
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Linq;");
		sb.AppendLine("using System.Runtime.CompilerServices;");
		sb.AppendLine("using Microsoft.Xrm.Sdk;");
		sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
		sb.AppendLine("using XrmPluginCore;");
		sb.AppendLine();

		var namespaceToUse = metadata.RegistrationNamespace;

		// Namespace declaration
		sb.AppendLine($"namespace {namespaceToUse}");
		sb.AppendLine("{");

		// Generate Image wrapper classes if we have images with attributes
		foreach (var image in imagesWithAttributes)
		{
			GenerateImageWrapperClass(sb, metadata, image);
		}

		GenerateActionWrapperClass(sb, metadata, imagesWithAttributes);

		// Close namespace
		sb.AppendLine("}");

		return sb.ToString();
	}

	/// <summary>
	/// Generates an Image wrapper class (PreImage or PostImage)
	/// </summary>
	private static void GenerateImageWrapperClass(StringBuilder sb, PluginStepMetadata metadata, ImageMetadata image)
	{
		// Simple class name - just "PreImage" or "PostImage"
		var className = image.WrapperClassName;

		// XML documentation
		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    /// Type-safe wrapper for {metadata.EntityTypeName} {metadata.EventOperation} {metadata.ExecutionStage} {image.ImageType}");
		sb.AppendLine("    /// </summary>");

		// CompilerGenerated attribute
		sb.AppendLine("    [CompilerGenerated]");

		// Class declaration with interface implementation
		sb.AppendLine($"    public class {className} : IEntityImageWrapper");
		sb.AppendLine("    {");

		// Private entity field
		sb.AppendLine("        private readonly Entity entity;");
		sb.AppendLine();

		// Constructor
		sb.AppendLine("        /// <summary>");
		sb.AppendLine($"        /// Initializes a new instance of {className}");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        /// <param name=\"entity\">The image entity</param>");
		sb.AppendLine($"        public {className}(Entity entity)");
		sb.AppendLine("        {");
		sb.AppendLine("            this.entity = entity ?? throw new ArgumentNullException(nameof(entity));");
		sb.AppendLine("        }");
		sb.AppendLine();

		// Generate properties for each image attribute
		foreach (var attr in image.Attributes)
		{
			GenerateProperty(sb, attr);
		}

		// ToEntity method - uses SDK's ToEntity<T>() for early-bound access
		sb.AppendLine("        /// <summary>");
		sb.AppendLine("        /// Converts the underlying Entity to an early-bound entity type");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        /// <typeparam name=\"T\">The early-bound entity type</typeparam>");
		sb.AppendLine("        public T ToEntity<T>() where T : Entity => entity.ToEntity<T>();");
		sb.AppendLine();

		// GetUnderlyingEntity method - provides access to the raw Entity
		sb.AppendLine("        /// <summary>");
		sb.AppendLine("        /// Gets the underlying Entity object for direct attribute access or service operations");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        public Entity GetUnderlyingEntity() => entity;");

		// Close class
		sb.AppendLine("    }");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a property for an entity attribute.
	/// GetAttributeValue&lt;T&gt; is already null-safe (returns default(T) for missing attributes),
	/// so we don't need the Contains check.
	/// </summary>
	private static void GenerateProperty(StringBuilder sb, AttributeMetadata attr)
	{
		var propertyType = attr.TypeName;

		// XML documentation
		sb.AppendLine("        /// <summary>");
		sb.AppendLine($"        /// Gets the {attr.PropertyName} attribute");
		sb.AppendLine("        /// </summary>");

		// Property declaration using expression body - GetAttributeValue<T> is already null-safe
		sb.AppendLine($"        public {propertyType} {attr.PropertyName} => entity.GetAttributeValue<{propertyType}>(\"{attr.LogicalName}\");");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates the ActionWrapper class that wraps the service method call.
	/// This is used by the runtime to discover and invoke the plugin action.
	/// </summary>
	private static void GenerateActionWrapperClass(StringBuilder sb, PluginStepMetadata metadata, List<ImageMetadata> images)
	{
		var hasPreImage = images.Any(i => i.ImageType == "PreImage");
		var hasPostImage = images.Any(i => i.ImageType == "PostImage");

		// XML documentation
		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    /// Generated action wrapper for {metadata.ServiceTypeName}.{metadata.HandlerMethodName}");
		sb.AppendLine("    /// </summary>");

		// CompilerGenerated attribute
		sb.AppendLine("    [CompilerGenerated]");

		// Class declaration
		sb.AppendLine("    internal sealed class ActionWrapper : IActionWrapper");
		sb.AppendLine("    {");

		// CreateAction method
		sb.AppendLine("        /// <summary>");
		sb.AppendLine("        /// Creates the action delegate that invokes the service method with appropriate images.");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        public Action<IExtendedServiceProvider> CreateAction()");
		sb.AppendLine("        {");
		sb.AppendLine("            return serviceProvider =>");
		sb.AppendLine("            {");

		// Get the service
		sb.AppendLine($"                var service = serviceProvider.GetRequiredService<{metadata.ServiceTypeFullName}>();");

		// Get images if needed
		if (hasPreImage || hasPostImage)
		{
			sb.AppendLine("                var context = serviceProvider.GetService<IPluginExecutionContext>();");
		}

		var args = new List<string>();
		if (hasPreImage)
		{
			sb.AppendLine("                var preImageEntity = context?.PreEntityImages?.Values?.FirstOrDefault();");
			sb.AppendLine("                var preImage = preImageEntity != null ? new PreImage(preImageEntity) : null;");
			args.Add("preImage");
		}
		if (hasPostImage)
		{
			sb.AppendLine("                var postImageEntity = context?.PostEntityImages?.Values?.FirstOrDefault();");
			sb.AppendLine("                var postImage = postImageEntity != null ? new PostImage(postImageEntity) : null;");
			args.Add("postImage");
		}

		var argsString = string.Join(", ", args);

		// Call the service method
		sb.AppendLine($"                service.{metadata.HandlerMethodName}({argsString});");

		sb.AppendLine("            };");
		sb.AppendLine("        }");

		// Close class
		sb.AppendLine("    }");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a unique hint name for the source file
	/// </summary>
	public static string GenerateHintName(PluginStepMetadata metadata)
	{
		// UniqueId already contains PluginClassName, so no need to duplicate
		return $"{metadata.UniqueId}.g.cs";
	}

	/// <summary>
	/// Merges multiple metadata instances that represent the same registration but with different attributes
	/// This handles the edge case where the same entity/operation/stage is registered multiple times
	/// </summary>
	public static PluginStepMetadata MergeMetadata(IEnumerable<PluginStepMetadata> metadataList)
	{
		var list = metadataList.ToList();
		if (!list.Any())
			return null;
		if (list.Count == 1)
			return list[0];

		var merged = new PluginStepMetadata
		{
			EntityTypeName = list[0].EntityTypeName,
			EventOperation = list[0].EventOperation,
			ExecutionStage = list[0].ExecutionStage,
			Namespace = list[0].Namespace,
			PluginClassName = list[0].PluginClassName,
			ServiceTypeName = list[0].ServiceTypeName,
			ServiceTypeFullName = list[0].ServiceTypeFullName,
			HandlerMethodName = list[0].HandlerMethodName,
			Images = []
		};

		// Merge all images (remove duplicates)
		var allImages = list.SelectMany(m => m.Images)
			.GroupBy(i => new { i.ImageType, i.ImageName })
			.Select(g =>
			{
				var first = g.First();
				return new ImageMetadata
				{
					ImageType = first.ImageType,
					ImageName = first.ImageName,
					Attributes = [.. g.SelectMany(i => i.Attributes)
							.GroupBy(a => a.LogicalName)
							.Select(ag => ag.First())]
				};
			})
			.ToList();

		merged.Images.AddRange(allImages);

		return merged;
	}
}
