using System.Collections.Generic;
using System.Linq;
using System.Text;
using XrmPluginCore.SourceGenerator.Models;
using static XrmPluginCore.SourceGenerator.CodeGeneration.Indent;

namespace XrmPluginCore.SourceGenerator.CodeGeneration;

/// <summary>
/// Generates wrapper class source code for plugin step registrations
/// </summary>
internal static class WrapperClassGenerator
{
	/// <summary>
	/// Generates a complete source file containing wrapper classes for a plugin step registration.
	/// Generates PreImage and PostImage wrappers, and ActionWrapper for the new method reference API.
	/// </summary>
	public static string GenerateWrapperClasses(PluginStepMetadata metadata)
	{
		var imagesWithAttributes = metadata.Images.Where(i => i.Attributes.Any()).ToList();

		// Estimate capacity: ~500 chars per image wrapper class + ~300 for ActionWrapper
		var estimatedCapacity = (imagesWithAttributes.Count * 500) + 500;
		var sb = new StringBuilder(estimatedCapacity);

		// File header and using directives
		sb.Append(GetFileHeader());

		var namespaceToUse = metadata.RegistrationNamespace;

		// Namespace declaration
		sb.AppendLine($"namespace {namespaceToUse}");
		sb.AppendLine("{");

		// Generate Image wrapper classes if we have images with attributes
		foreach (var image in imagesWithAttributes)
		{
			GenerateImageWrapperClass(sb, metadata, image);
		}

		GenerateActionWrapperClass(sb, metadata, imagesWithAttributes);

		// Close namespace
		sb.AppendLine("}");

		return sb.ToString();
	}

	/// <summary>
	/// Generates an Image wrapper class (PreImage or PostImage)
	/// </summary>
	private static void GenerateImageWrapperClass(StringBuilder sb, PluginStepMetadata metadata, ImageMetadata image)
	{
		var className = image.WrapperClassName;

		// Class header with documentation, attribute, field, and constructor
		sb.Append(GetImageClassHeader(
			className,
			metadata.EntityTypeName,
			metadata.EntityTypeFullName,
			metadata.EventOperation,
			metadata.ExecutionStage,
			image.ImageType));

		// Generate properties for each image attribute
		foreach (var attr in image.Attributes)
		{
			sb.Append(GetPropertyTemplate(attr.TypeName, attr.PropertyName, attr.XmlDocumentation));
		}

		// Close class
		sb.Append(L1).Append("}");
	}

	/// <summary>
	/// Generates the ActionWrapper class that wraps the service method call.
	/// This is used by the runtime to discover and invoke the plugin action.
	/// </summary>
	private static void GenerateActionWrapperClass(StringBuilder sb, PluginStepMetadata metadata, List<ImageMetadata> images)
	{
		var hasPreImage = images.Any(i => i.ImageType == "PreImage");
		var hasPostImage = images.Any(i => i.ImageType == "PostImage");

		// ActionWrapper header with documentation, class declaration, and service retrieval
		sb.Append(GetActionWrapperHeader(
			metadata.ServiceTypeName,
			metadata.HandlerMethodName,
			metadata.ServiceTypeFullName));

		// Get context if images are needed
		if (hasPreImage || hasPostImage)
		{
			sb.AppendLine();
			sb.AppendLine($"{L4}var context = serviceProvider.GetRequiredService<IPluginExecutionContext>();");
		}

		var args = new List<string>();
		if (hasPreImage)
		{
			sb.AppendLine();
			sb.Append(GetPreImageRetrieval());
			args.Add("preImage");
		}
		if (hasPostImage)
		{
			sb.AppendLine();
			sb.Append(GetPostImageRetrieval());
			args.Add("postImage");
		}

		var argsString = string.Join(", ", args);

		// ActionWrapper footer with method invocation and closing braces
		sb.AppendLine();
		sb.Append(GetActionWrapperFooter(metadata.HandlerMethodName, argsString));
	}

	/// <summary>
	/// Generates a unique hint name for the source file
	/// </summary>
	public static string GenerateHintName(PluginStepMetadata metadata)
	{
		// UniqueId already contains PluginClassName, so no need to duplicate
		return $"{metadata.UniqueId}.g.cs";
	}

	#region Template Methods

	private static string GetFileHeader() =>
"""
// <auto-generated />

using System;
using System.Linq;
using System.Runtime.CompilerServices;
using Microsoft.Xrm.Sdk;
using Microsoft.Extensions.DependencyInjection;
using XrmPluginCore;

""";

	private static string GetImageClassHeader(
		string className,
		string entityTypeName,
		string entityTypeFullName,
		string eventOperation,
		string executionStage,
		string imageType) =>
		$"{L1}/// <summary>\n" +
		$"{L1}/// Type-safe wrapper for {entityTypeName} {eventOperation} {executionStage} {imageType}\n" +
		$"{L1}/// </summary>\n" +
		$"{L1}[CompilerGenerated]\n" +
		$"{L1}public sealed class {className} : IEntityImageWrapper<{entityTypeFullName}>\n" +
		$"{L1}{{\n" +
		$"{L2}public {className}(Entity entity)\n" +
		$"{L2}{{\n" +
		$"{L3}Entity = entity.ToEntity<{entityTypeFullName}>();\n" +
		$"{L2}}}\n\n" +
		$"{L2}public {entityTypeFullName} Entity {{ get; }}\n\n";

	private static string GetPropertyTemplate(string propertyType, string propertyName, string xmlDoc)
	{
		if (string.IsNullOrWhiteSpace(xmlDoc))
		{
			return $"{L2}public {propertyType} {propertyName} => Entity.{propertyName};\n\n";
		}

		return $"{xmlDoc}\n{L2}public {propertyType} {propertyName} => Entity.{propertyName};\n\n";
	}

	private static string GetActionWrapperHeader(string serviceTypeName, string methodName, string serviceFullName) =>
		$"{L1}/// <summary>\n" +
		$"{L1}/// Generated action wrapper for {serviceTypeName}.{methodName}\n" +
		$"{L1}/// </summary>\n" +
		$"{L1}[CompilerGenerated]\n" +
		$"{L1}internal sealed class ActionWrapper : IActionWrapper\n" +
		$"{L1}{{\n" +
		$"{L2}/// <summary>\n" +
		$"{L2}/// Creates the action delegate that invokes the service method with appropriate images.\n" +
		$"{L2}/// </summary>\n" +
		$"{L2}public Action<IExtendedServiceProvider> CreateAction()\n" +
		$"{L2}{{\n" +
		$"{L3}return serviceProvider =>\n" +
		$"{L3}{{\n" +
		$"{L4}var service = serviceProvider.GetRequiredService<{serviceFullName}>();";

	private static string GetPreImageRetrieval() =>
		$"{L4}var preImageEntity = context?.PreEntityImages?.Values?.FirstOrDefault();\n" +
		$"{L4}var preImage = preImageEntity != null ? new PreImage(preImageEntity) : null;";

	private static string GetPostImageRetrieval() =>
		$"{L4}var postImageEntity = context?.PostEntityImages?.Values?.FirstOrDefault();\n" +
		$"{L4}var postImage = postImageEntity != null ? new PostImage(postImageEntity) : null;";

	private static string GetActionWrapperFooter(string methodName, string argsString) =>
		$"{L4}service.{methodName}({argsString});\n" +
		$"{L3}}};\n" +
		$"{L2}}}\n" +
		$"{L1}}}\n\n";

	#endregion
}
