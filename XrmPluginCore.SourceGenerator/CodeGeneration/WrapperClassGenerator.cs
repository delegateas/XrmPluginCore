using System.Collections.Generic;
using System.Linq;
using System.Text;
using XrmPluginCore.SourceGenerator.Models;

namespace XrmPluginCore.SourceGenerator.CodeGeneration;

/// <summary>
/// Generates wrapper class source code for plugin step registrations
/// </summary>
internal static class WrapperClassGenerator
{
	/// <summary>
	/// Generates a complete source file containing wrapper classes for a plugin step registration.
	/// Only generates PreImage and PostImage wrappers (no Target wrapper).
	/// </summary>
	public static string GenerateWrapperClasses(PluginStepMetadata metadata)
	{
		// Only generate if there are images with attributes
		var imagesWithAttributes = metadata.Images.Where(i => i.Attributes.Any()).ToList();
		if (!imagesWithAttributes.Any())
		{
			return null;
		}

		// Estimate capacity: ~500 chars per image wrapper class
		var estimatedCapacity = imagesWithAttributes.Count * 500;
		var sb = new StringBuilder(estimatedCapacity);

		// File header
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine();

		// Using directives
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Runtime.CompilerServices;");
		sb.AppendLine("using Microsoft.Xrm.Sdk;");
		sb.AppendLine("using XrmPluginCore;");
		sb.AppendLine();

		// Namespace declaration on the format {Namespace}.PluginImages.{PluginClassName}.{EntityTypeName}{EventOperation}{ExecutionStage}
		sb.AppendLine($"namespace {metadata.ImageNamespace}");
		sb.AppendLine("{");

		// Generate Image wrapper classes
		foreach (var image in imagesWithAttributes)
		{
			GenerateImageWrapperClass(sb, metadata, image);
		}

		// Close namespace
		sb.AppendLine("}");

		return sb.ToString();
	}

	/// <summary>
	/// Generates an Image wrapper class (PreImage or PostImage)
	/// </summary>
	private static void GenerateImageWrapperClass(StringBuilder sb, PluginStepMetadata metadata, ImageMetadata image)
	{
		// Simple class name - just "PreImage" or "PostImage"
		var className = image.WrapperClassName;

		// XML documentation
		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    /// Type-safe wrapper for {metadata.EntityTypeName} {metadata.EventOperation} {metadata.ExecutionStage} {image.ImageType}");
		sb.AppendLine("    /// </summary>");

		// CompilerGenerated attribute
		sb.AppendLine("    [CompilerGenerated]");

		// Class declaration with interface implementation
		sb.AppendLine($"    public class {className} : IEntityImageWrapper");
		sb.AppendLine("    {");

		// Private entity field
		sb.AppendLine("        private readonly Entity entity;");
		sb.AppendLine();

		// Constructor
		sb.AppendLine("        /// <summary>");
		sb.AppendLine($"        /// Initializes a new instance of {className}");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        /// <param name=\"entity\">The image entity</param>");
		sb.AppendLine($"        public {className}(Entity entity)");
		sb.AppendLine("        {");
		sb.AppendLine("            this.entity = entity ?? throw new ArgumentNullException(nameof(entity));");
		sb.AppendLine("        }");
		sb.AppendLine();

		// Generate properties for each image attribute
		foreach (var attr in image.Attributes)
		{
			GenerateProperty(sb, attr);
		}

		// ToEntity method - uses SDK's ToEntity<T>() for early-bound access
		sb.AppendLine("        /// <summary>");
		sb.AppendLine("        /// Converts the underlying Entity to an early-bound entity type");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        /// <typeparam name=\"T\">The early-bound entity type</typeparam>");
		sb.AppendLine("        public T ToEntity<T>() where T : Entity => entity.ToEntity<T>();");
		sb.AppendLine();

		// GetUnderlyingEntity method - provides access to the raw Entity
		sb.AppendLine("        /// <summary>");
		sb.AppendLine("        /// Gets the underlying Entity object for direct attribute access or service operations");
		sb.AppendLine("        /// </summary>");
		sb.AppendLine("        public Entity GetUnderlyingEntity() => entity;");

		// Close class
		sb.AppendLine("    }");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a property for an entity attribute.
	/// GetAttributeValue&lt;T&gt; is already null-safe (returns default(T) for missing attributes),
	/// so we don't need the Contains check.
	/// </summary>
	private static void GenerateProperty(StringBuilder sb, AttributeMetadata attr)
	{
		var propertyType = attr.TypeName;

		// XML documentation
		sb.AppendLine("        /// <summary>");
		sb.AppendLine($"        /// Gets the {attr.PropertyName} attribute");
		sb.AppendLine("        /// </summary>");

		// Property declaration using expression body - GetAttributeValue<T> is already null-safe
		sb.AppendLine($"        public {propertyType} {attr.PropertyName} => entity.GetAttributeValue<{propertyType}>(\"{attr.LogicalName}\");");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a unique hint name for the source file
	/// </summary>
	public static string GenerateHintName(PluginStepMetadata metadata)
	{
		// UniqueId already contains PluginClassName, so no need to duplicate
		return $"{metadata.UniqueId}.g.cs";
	}

	/// <summary>
	/// Merges multiple metadata instances that represent the same registration but with different attributes
	/// This handles the edge case where the same entity/operation/stage is registered multiple times
	/// </summary>
	public static PluginStepMetadata MergeMetadata(IEnumerable<PluginStepMetadata> metadataList)
	{
		var list = metadataList.ToList();
		if (!list.Any())
			return null;
		if (list.Count == 1)
			return list[0];

		var merged = new PluginStepMetadata
		{
			EntityTypeName = list[0].EntityTypeName,
			EventOperation = list[0].EventOperation,
			ExecutionStage = list[0].ExecutionStage,
			Namespace = list[0].Namespace,
			PluginClassName = list[0].PluginClassName,
			Images = []
		};

		// Merge all images (remove duplicates)
		var allImages = list.SelectMany(m => m.Images)
			.GroupBy(i => new { i.ImageType, i.ImageName })
			.Select(g =>
			{
				var first = g.First();
				return new ImageMetadata
				{
					ImageType = first.ImageType,
					ImageName = first.ImageName,
					Attributes = [.. g.SelectMany(i => i.Attributes)
							.GroupBy(a => a.LogicalName)
							.Select(ag => ag.First())]
				};
			})
			.ToList();

		merged.Images.AddRange(allImages);

		return merged;
	}
}
