using Microsoft.Extensions.DependencyInjection;
using Microsoft.Xrm.Sdk;
using XrmPluginCore.Enums;

// Import the generated PreImage/PostImage from the namespace
using XrmPluginCore.Tests.TestPlugins.TypeSafe.PluginImages.TypeSafeAccountPlugin.AccountUpdatePreOperation;

namespace XrmPluginCore.Tests.TestPlugins.TypeSafe
{
    /// <summary>
    /// Test plugin using the type-safe image API.
    /// PreImage and PostImage wrappers are generated by the source generator
    /// and passed directly to the action callback.
    /// </summary>
    public class TypeSafeAccountPlugin : Plugin
    {
        public bool UpdateExecuted { get; private set; }
        public PreImage LastPreImage { get; private set; }
        public PostImage LastPostImage { get; private set; }

        public TypeSafeAccountPlugin()
        {
            // Type-safe API: Images are passed directly to the action
            // Using WithPreImage/WithPostImage enforces that Execute receives both images
            RegisterStep<Account, TypeSafeAccountService>(EventOperation.Update, ExecutionStage.PreOperation)
                .AddFilteredAttributes(x => x.Name, x => x.Accountnumber)
                .WithPreImage(x => x.Name, x => x.Accountnumber, x => x.Revenue)
                .WithPostImage(x => x.Name, x => x.Accountnumber)
                .Execute<PreImage, PostImage>((service, pre, post) => service.HandleUpdate(pre, post));
        }

        protected override IServiceCollection OnBeforeBuildServiceProvider(IServiceCollection services)
        {
            services.AddScoped(_ => new TypeSafeAccountService(this));
            return base.OnBeforeBuildServiceProvider(services);
        }

        internal void SetExecutionResult(PreImage preImage, PostImage postImage)
        {
            UpdateExecuted = true;
            LastPreImage = preImage;
            LastPostImage = postImage;
        }
    }

    /// <summary>
    /// Simple Account entity class for testing
    /// </summary>
    [Microsoft.Xrm.Sdk.Client.EntityLogicalName("account")]
    public class Account : Entity
    {
        public Account() : base("account") { }

        [AttributeLogicalName("name")]
        public string Name
        {
            get => GetAttributeValue<string>("name");
            set => SetAttributeValue("name", value);
        }

        [AttributeLogicalName("accountnumber")]
        public string Accountnumber
        {
            get => GetAttributeValue<string>("accountnumber");
            set => SetAttributeValue("accountnumber", value);
        }

        [AttributeLogicalName("revenue")]
        public Money Revenue
        {
            get => GetAttributeValue<Money>("revenue");
            set => SetAttributeValue("revenue", value);
        }
    }
}
